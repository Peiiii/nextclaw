## 迭代制度（docs/logs）

- 每个迭代在 `docs/logs` 下新增一个目录
- 目录内按版本号建立子目录，命名为 `v0.0.1-版本的slug`（语义化）
- 每个版本目录至少包含：
  - 迭代完成说明（改了什么）
  - 测试/验证/验收方式
  - 发布/部署方式
- 可选文档：PRD、讨论记录等

## 指令/Command 机制

- 新增指令统一记录在 `commands/commands.md`，并在此处索引
- 约定元指令：输入 `/new-command` 触发创建新指令流程
- 指令文件结构：每条指令包含名称、用途、输入格式、输出/期望行为
- 后续新增或修改指令时，更新 `commands/commands.md` 并保持此处索引最新
- 已有指令：
  - `/new-command`：创建新指令
  - `/config-meta`：调整或更新本文件（AGENTS.md）的机制/元信息（含 project-rulebook 模块）
  - `/check-meta`：检查 AGENTS.md 机制问题（自相矛盾/未遵循规范等）
  - `/new-rule`：创建新规则条目（按 Rulebook 模板）
  - `/commit`：进行提交操作（提交信息需使用英文）
  - `/validate`：运行项目验证，至少包含 `build`、`lint`、`tsc`，必要时冒烟测试

## 规则/Rule 机制

- 规则直接维护在本文件末尾的 **Rulebook / Project Rulebook** 区域
- 约定元指令：输入 `/new-rule` 触发创建新规则流程
- 规则条目必须包含：名称（英文 kebab-case）、约束/适用范围、示例、反例、执行方式（工具/流程）、维护责任人
- 规则书写模板（每条规则均需按此结构填写）：
  - **<rule-name>**：
    - 约束/适用范围：
    - 示例：
    - 反例：
    - 执行方式：
    - 维护责任人：
- 通用规则 vs 项目规则判定依据：
  - 通用规则：不依赖具体项目的目录结构、工具链、发布流程或业务背景，适用于多数项目的工作方法/协作规范。
  - 项目规则：依赖本项目的特定路径、工具链、部署流程、合规要求或业务背景，迁移到其他项目将失效或引入误导。
- Project Rulebook 机制说明（适用于规则层面的元说明）：
  - 机制与 Rulebook 完全一致，仅记录项目专属规则。
  - 当规则具备跨项目复用价值时，必须迁移到 Rulebook。
- 后续新增或修改规则时，直接在本文件的 **Rulebook / Project Rulebook** 区域追加/更新
- 默认所有规则必须严格遵守（无额外声明即视为强制）；如需例外必须在规则中明确说明

## Rulebook

- **post-dev-stage-validation**：
  - 约束/适用范围：每个开发阶段结束必须做验证，至少运行 `build`、`lint`、`tsc`；如确认无关可说明理由并省略；如涉及可运行/用户可见改动需补冒烟测试。
  - 示例：完成一轮功能改动后执行 `pnpm build && pnpm lint && pnpm tsc`，并补一条 CLI 冒烟。
  - 反例：只修改代码但不做任何验证就汇报完成。
  - 执行方式：按阶段执行 `build/lint/tsc`，必要时追加真实命令/请求冒烟并记录结果。
  - 维护责任人：当次交付 owner。
- **no-self-commit-without-request**：
  - 约束/适用范围：除非用户明确要求，否则禁止擅自提交/推送代码。
  - 示例：用户说“帮我提交”，才执行 `git commit`。
  - 反例：用户未要求却自行提交或推送。
  - 执行方式：在执行提交/推送前确认用户明确指令。
  - 维护责任人：当前助手。
- **use-chinese-when-communicating**：
  - 约束/适用范围：与用户交流时必须使用中文。
  - 示例：需求说明、方案与进度均使用中文回复。
  - 反例：用英文回复用户问题。
  - 执行方式：所有对话输出保持中文。
  - 维护责任人：当前助手。
- **smoke-test-required**：
  - 约束/适用范围：所有用户可见/可运行行为改动必须附带冒烟测试；发布/上线前必须记录冒烟结果（命令与观察点）。
  - 示例：新增 CLI 功能后执行真实命令并记录输出要点。
  - 反例：只做单元验证、不做任何冒烟就声称可用。
  - 执行方式：按组件选择 CLI/API/UI 最小可行流程进行验证并记录。
  - 维护责任人：当次交付 owner。
- **smoke-no-local-repo-writes**：
  - 约束/适用范围：冒烟测试默认在非 local/非仓库目录环境执行；禁止将冒烟测试的安装/数据写入仓库目录或其子目录，需使用全局/隔离路径并在测试后清理。
  - 示例：使用 `/tmp` 或独立目录作为 `NEXTCLAW_HOME` 做冒烟。
  - 反例：在仓库目录内执行初始化导致写入测试数据。
  - 执行方式：优先 global scope 或临时目录；必要时清理测试目录。
  - 维护责任人：当次交付 owner。
- **reply-prefix-required**：
  - 约束/适用范围：所有对用户的回复必须以前缀`[我严格遵守规则]`开头（含本条指令当次起立即生效）。
  - 示例：`[我严格遵守规则]已完成修改。`
  - 反例：回复未带前缀或仅部分回复带前缀。
  - 执行方式：所有输出前置该前缀。
  - 维护责任人：当前助手。
- **infer-intent-and-be-proactive**：
  - 约束/适用范围：用户提出需求或评价时，必须推理其深层意图，不仅复述字面，并给出主动、有用的下一步建议。
  - 示例：用户说“太慢了”，应推断关注点是性能/流程，并提出可行优化路径与验证计划。
  - 反例：只回答“好的，我会加快”，不提供具体行动或方案。
  - 执行方式：在回复前先写出“深层意图”判断，再给出最小可执行方案与后续选项。
  - 维护责任人：当前助手。
- **config-meta-no-new-modules**：
  - 约束/适用范围：执行 `/config-meta` 时，除非用户明确提出，否则禁止在 AGENTS.md 中新增模块；仅允许在已有模块内进行增删改。
  - 示例：用户要求“更新 Project Rulebook”，则只在该模块内修改条目。
  - 反例：用户未提“新增模块”，却新增了新的一级标题模块。
  - 执行方式：先定位已有模块，再就地修改；如需新增模块必须先征得用户明确同意。
  - 维护责任人：当前助手。
- **deep-think-mode**：
  - 约束/适用范围：当用户明确启动“深思模式”后，每次回复必须先进行思考/反思，再输出内容，并在回复前缀中追加 `[深思模式]`（放在 `[我严格遵守规则]` 之后）。
  - 示例：用户说“启动深思模式”，后续回复应以 `[我严格遵守规则][深思模式]` 开头，并先给出简要反思再作答。
  - 反例：深思模式开启后仍只输出常规回答、或缺少 `[深思模式]` 前缀。
  - 执行方式：识别“启动/开启深思模式”的指令；开启后持续生效，直到用户明确关闭。
  - 维护责任人：当前助手。
- **exec-as-ceo-cto-pm**：
  - 约束/适用范围：思考与决策需同时站在 CEO + CTO（架构师）+ 产品经理视角。
  - 示例：既考虑产品价值，又考虑技术架构与交付路径。
  - 反例：只从实现角度回答，不考虑产品与架构影响。
  - 执行方式：方案输出需包含产品价值、技术可行性与结构性影响。
  - 维护责任人：当前助手。
- **best-solution-over-cost**：
  - 约束/适用范围：优先最佳方案，不以开发成本为先。
  - 示例：给出长期最优架构而非最省时方案。
  - 反例：仅以“省时间/省人力”为理由选择次优方案。
  - 执行方式：方案对比以长期收益与质量为首要依据。
  - 维护责任人：当前助手。
- **release-requires-remote-migrations**：
  - 约束/适用范围：仅当发布涉及后端或数据库变更时，必须执行远程 migration，并对关键 API 做线上冒烟验证。
  - 示例：数据库字段变更发布前执行 migration，并验证关键接口返回。
  - 反例：变更数据库后直接发布，不跑 migration 或不做线上验证。
  - 执行方式：先判断是否涉及后端/数据库变更；是则加入 migration + 线上关键 API 冒烟。
  - 维护责任人：当次交付 owner。
- **release-must-be-closed-loop**：
  - 约束/适用范围：“发布/上线”必须形成闭环，但闭环动作需按项目/变更类型按需选择；不适用的动作必须明确为“不适用”并说明理由。
  - 示例：仅发布 NPM 包时，执行 npm 发布 + 冒烟验证，migration/deploy 标注不适用。
  - 反例：遗漏必须的步骤（如涉及后端却跳过部署或线上冒烟），或不说明为何省略。
  - 执行方式：发布前判断变更类型并选择动作；记录已执行/不适用项及理由。
  - 维护责任人：当次交付 owner。
- **release-coverage-required**：
  - 约束/适用范围：发布必须覆盖所有需要发布的组件；若用户未明确范围必须先确认。
  - 示例：变更涉及多个包时确认发布范围并全部覆盖。
  - 反例：只发布部分组件导致功能不一致。
  - 执行方式：列出受影响组件并确认发布清单。
  - 维护责任人：当前助手。
- **release-default-full-when-no-choice**：
  - 约束/适用范围：用户明确要求“直接发布/不做选择”时，默认执行全量发布闭环（覆盖本次变更涉及的组件），不得再次要求用户决策。
  - 示例：用户说“直接发布”，则全量发布并完成闭环。
  - 反例：仍追问要发布哪些组件。
  - 执行方式：自动汇总影响范围并执行全量发布闭环。
  - 维护责任人：当前助手。
- **post-release-docs-review**：
  - 约束/适用范围：每次发布后必须评估是否需要更新/调整功能文档，并按需完成更新。
  - 示例：新增/变更 CLI 功能后，同步更新 README/USAGE/相关指南。
  - 反例：发布后发现文档缺失或过期但未更新。
  - 执行方式：发布闭环中加入“文档影响检查”，列出需更新的文档并完成修改或明确说明“不适用”。
  - 维护责任人：当次交付 owner。
- **npm-release-process-must-follow**：
  - 约束/适用范围：NPM 包发布必须遵循当前项目约定的发布流程文档。
  - 示例：按项目发布文档执行 changeset → version → publish。
  - 反例：跳过 changeset 或未执行发布前检查。
  - 执行方式：严格按文档流程执行并记录结果。
  - 维护责任人：当次交付 owner。
- **full-completion-implies-full-release**：
  - 约束/适用范围：用户指令包含“完成所有/完成全部”时，默认执行完整上线闭环：远程 migration → 全量组件发布/部署（含版本号提升与发布）→ 线上冒烟验证。
  - 示例：用户说“完成全部”，则全量发布并做线上验证。
  - 反例：只完成部分发布或省略线上验证。
  - 执行方式：识别关键词后自动执行全流程闭环。
  - 维护责任人：当前助手。
- **no-duplicate-functionality**：
  - 约束/适用范围：同一功能不得重复实现，保持唯一性。
  - 示例：统一入口复用同一实现。
  - 反例：同一逻辑在多个文件重复实现。
  - 执行方式：抽象复用、删除重复实现。
  - 维护责任人：当前助手。
- **ui-no-business-logic**：
  - 约束/适用范围：UI 组件禁止依赖业务逻辑。
  - 示例：UI 仅负责展示与交互，业务放在 service/logic 层。
  - 反例：UI 内直接调用或实现核心业务流程。
  - 执行方式：业务逻辑下沉到服务层并通过接口调用。
  - 维护责任人：当前助手。
- **future-fast-pace**：
  - 约束/适用范围：保持面向未来的高节奏开发方式。
  - 示例：以快速迭代、清晰里程碑推进。
  - 反例：无节奏、拖延或缺少交付目标。
  - 执行方式：输出阶段目标与明确交付物。
  - 维护责任人：当前助手。
- **avoid-stack-bloat-and-unnecessary-legacy-compat**：
  - 约束/适用范围：禁止无节制叠加技术栈；禁止为了历史兼容引入不必要复杂性。仅在“非常重要”（核心用户受影响、合规要求、生产稳定性）时允许兼容层。
  - 示例：已有 TypeScript + React 体系下优先在现栈内演进；对低价值旧接口直接迁移并提供清晰升级说明，而非长期双轨维护。
  - 反例：仅为“可能有人在用旧版本”就长期保留两套实现/两套路由/两套配置结构。
  - 执行方式：方案评审时必须先做“必要性判断”（是否核心、是否合规、是否影响稳定性）；不满足则删除兼容路径或拒绝新增技术栈，并在变更说明中记录取舍。
  - 维护责任人：当前助手。
- **ai-verifiable-first**：
  - 约束/适用范围：方案与实现优先选择可由 AI 或自动流程直接验证的路径，尽量减少“必须人工主观判断”的验收环节。
  - 示例：新增规则后补可执行校验脚本或结构化检查步骤，使助手可独立完成验证并输出结果。
  - 反例：仅给出“人工看起来没问题”且没有可重复执行的验证方法。
  - 执行方式：在设计与交付时先定义可自动验证的验收条件（命令、断言、输出观察点），并在迭代日志记录。
  - 维护责任人：当前助手。
- **automate-repetitive-workflows**：
  - 约束/适用范围：识别高频重复流程并在合适时机封装为自动化工具/命令，避免长期手工重复操作。
  - 示例：将重复的校验、发布前检查、日志生成流程沉淀为脚本或统一命令入口。
  - 反例：同一流程反复手动执行且每次步骤不一致，导致效率低和易漏项。
  - 执行方式：在复盘中标记重复流程，达到复用阈值后抽象为脚本/命令，并更新文档与使用说明。
  - 维护责任人：当前助手。

## Project Rulebook

- （当前为空）
